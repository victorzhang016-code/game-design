  // ååˆ¶é€‰æ‹© - ä¿®å¤ç‰ˆ
  const handleCounterChoice = (card: SkillCardData) => {
    if (phase !== 'counter-choice') return;
    if (!pendingSkill) return;
    
    // æ£€æŸ¥æ˜¯å¦è§¦å‘ååˆ¶ï¼ˆåŒ…æ‹¬é€šç”¨ååˆ¶å¡ï¼‰
    const isCounter = (card.isUniversalCounter) || (card.counterSkill && card.counterSkill === pendingSkill.name);
    
    if (isCounter) {
      // ååˆ¶æˆåŠŸï¼
      setCounterSuccess(true);
      setBattleLog(prev => [...prev, `âš¡ COUNTER! You used ${card.name} to block ${pendingSkill.name}!`]);
      
      // 1. å…ˆæ‰§è¡Œå¡ç‰ŒåŸºç¡€æ•ˆæœ
      if (card.type === 'ATTACK') {
        // æ”»å‡»å¡ï¼šé€ æˆä¼¤å®³
        const damageReduction = getBossDamageReduction();
        const actualDamage = Math.floor(card.power * damageReduction);
        
        setEnemyHp(currentEnemyHp => {
          const newEnemyHp = Math.max(0, currentEnemyHp - actualDamage);
          
          if (enemyType !== 'BATTLE' && damageReduction < 1.0) {
            const reducedAmount = card.power - actualDamage;
            setBattleLog(prev => [...prev, `ğŸ’¥ Dealt ${actualDamage} damage! (${reducedAmount} reduced by armor)`]);
          } else {
            setBattleLog(prev => [...prev, `ğŸ’¥ Dealt ${actualDamage} damage!`]);
          }
          
          return newEnemyHp;
        });
        
        setEnemyShake(true);
        setTimeout(() => setEnemyShake(false), 500);
      } else if (card.type === 'DEFEND') {
        // é˜²å¾¡å¡ï¼šè·å¾—æŠ¤ç›¾
        setDefenseReady(true);
        setDefenseAmount(card.power);
        setBattleLog(prev => [...prev, `ğŸ›¡ï¸ Gained ${card.power} shield!`]);
      } else if (card.type === 'HEAL') {
        // æ²»ç–—å¡ï¼šæ¢å¤HP
        setPlayerHp(currentHp => {
          const newHp = Math.min(playerMaxHp, currentHp + card.power);
          const actualHeal = newHp - currentHp;
          setBattleLog(prev => [...prev, `ğŸ’š Healed ${actualHeal} HP!`]);
          return newHp;
        });
        
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ¸…é™¤ç¼çƒ§çŠ¶æ€
        if (card.removeBurn && isBurning) {
          setIsBurning(false);
          setBurnTurns(0);
          setBattleLog(prev => [...prev, 'ğŸ’Š BURN STATUS CURED!']);
        }
      }
      
      // 2. å†æ‰§è¡Œååˆ¶ç‰¹æ•ˆ
      if (card.counterShield) {
        // é˜²ç«é“²ååˆ¶ï¼šé¢å¤–æŠ¤ç›¾
        setDefenseReady(true);
        setDefenseAmount(prev => prev + card.counterShield);
        setBattleLog(prev => [...prev, `ğŸ›¡ï¸ Counter bonus: +${card.counterShield} extra shield!`]);
      }
      
      if (card.counterHeal) {
        // æ²™æ¡¶ååˆ¶ï¼šé¢å¤–æ²»ç–—
        setPlayerHp(currentHp => {
          const healAmount = card.counterHeal || 0;
          const newHp = Math.min(playerMaxHp, currentHp + healAmount);
          const actualHeal = newHp - currentHp;
          setBattleLog(prev => [...prev, `ğŸ’š Counter bonus: +${actualHeal} HP!`]);
          return newHp;
        });
      }
      
      if (card.counterClearDebuffs) {
        // ç‡ƒçƒ§ä¸‰è§’ååˆ¶ï¼šæ¸…é™¤æ‰€æœ‰è´Ÿé¢çŠ¶æ€
        if (isBurning) {
          setIsBurning(false);
          setBurnTurns(0);
          setBattleLog(prev => [...prev, `âœ¨ Counter effect: All debuffs cleared!`]);
        }
      }
      
      if (card.counterDamage) {
        // é¢å¤–ä¼¤å®³ï¼ˆå¦‚æœå­˜åœ¨counterDamageå±æ€§ï¼‰
        const damageReduction = getBossDamageReduction();
        const bonusDamage = Math.floor(card.counterDamage * damageReduction);
        
        setEnemyHp(currentEnemyHp => {
          const newEnemyHp = Math.max(0, currentEnemyHp - bonusDamage);
          setBattleLog(prev => [...prev, `ğŸ’¥ Counter bonus: +${bonusDamage} extra damage!`]);
          return newEnemyHp;
        });
        
        setEnemyShake(true);
        setTimeout(() => setEnemyShake(false), 500);
      }
      
      if (card.counterReflect) {
        // å®‰å…¨æ’åº§ååˆ¶ï¼šåå¼¹ä¼¤å®³
        const reflectDamage = Math.floor(pendingSkill.damage * card.counterReflect);
        
        setEnemyHp(currentEnemyHp => {
          const newEnemyHp = Math.max(0, currentEnemyHp - reflectDamage);
          setBattleLog(prev => [...prev, `ğŸ”Œ Counter effect: Reflected ${reflectDamage} damage! (${Math.floor(card.counterReflect * 100)}% of ${pendingSkill.damage})`]);
          return newEnemyHp;
        });
        
        setEnemyShake(true);
        setTimeout(() => setEnemyShake(false), 500);
      }
      
      setBattleLog(prev => [...prev, `âœ… Enemy skill prevented!`]);
      
      // æ¸…é™¤é¢„å‘Šçš„æ•ŒäººæŠ€èƒ½
      setPendingSkill(null);
      
      setTimeout(() => {
        setCounterSuccess(false);
      }, 1500);
      
      // æ£€æŸ¥æ•Œäººæ˜¯å¦è¢«å‡»è´¥ï¼ˆå»¶è¿Ÿæ£€æŸ¥ç¡®ä¿çŠ¶æ€æ›´æ–°ï¼‰
      setTimeout(() => {
        if (enemyHp <= 0) {
          setTimeout(() => setPhase('player-won'), 300);
        } else {
          // ååˆ¶æˆåŠŸåè¿›å…¥æ•Œäººå›åˆ
          enemyTurn();
        }
      }, 2000);
    } else {
      // æ²¡æœ‰ååˆ¶ï¼ŒæŠ€èƒ½å‘½ä¸­ï¼æ‰§è¡ŒæŠ€èƒ½æ•ˆæœ
      setBattleLog(prev => [...prev, `You used ${card.name}, but couldn't counter the skill!`]);
      
      const enemyDamage = pendingSkill.damage;
      let actualDamage = enemyDamage;
      
      // æ£€æŸ¥æ˜¯å¦æœ‰é˜²å¾¡å€¼
      const currentDefense = pendingSkill.currentDefense;
      
      if (currentDefense > 0) {
        // æŠ¤ç›¾å¤§å¹…å‡å°‘ä¼¤å®³
        actualDamage = Math.max(0, enemyDamage - currentDefense);
        setBattleLog(prev => [...prev, `ğŸ”¥ ${pendingSkill.name}! Enemy deals ${enemyDamage}! You blocked ${Math.min(currentDefense, enemyDamage)} damage!`]);
        setDefenseReady(false);
        setDefenseAmount(0);
        // å³ä½¿æœ‰æŠ¤ç›¾ä¹Ÿè§¦å‘éœ‡åŠ¨ï¼ˆè¡¨ç¤ºå—å‡»ï¼‰
        if (actualDamage > 0) {
          setPlayerShake(true);
          setTimeout(() => setPlayerShake(false), 500);
        }
      } else {
        // åº”ç”¨è£…å¤‡å‡ä¼¤ï¼ˆè£…å¤‡é½å…¨æ—¶ä¼¤å®³ * 0.9ï¼‰
        if (isFullyEquipped) {
          actualDamage = Math.floor(enemyDamage * 0.9);
          const reducedDamage = enemyDamage - actualDamage;
          setBattleLog(prev => [...prev, `ğŸ”¥ ${pendingSkill.name}! Deals ${enemyDamage}! Equipment reduced ${reducedDamage} damage! Took ${actualDamage} damage!`]);
        } else {
          setBattleLog(prev => [...prev, `ğŸ”¥ ${pendingSkill.name}! Dealt ${actualDamage} damage!`]);
        }
        // è§¦å‘ç©å®¶å—å‡»åŠ¨ç”»
        setPlayerShake(true);
        setTimeout(() => setPlayerShake(false), 500);
      }
      
      // æŠ€èƒ½é¢å¤–æ•ˆæœï¼šæœ‰æ›´é«˜å‡ ç‡æ–½åŠ ç¼çƒ§
      if (!isBurning && actualDamage > 0) {
        setIsBurning(true);
        setBurnTurns(3);
        setBattleLog(prev => [...prev, 'ğŸ”¥ You are BURNING! Takes 3-5 damage per turn for 3 turns!']);
      }
      
      // æ¸…é™¤pendingSkill
      setPendingSkill(null);
      
      // ä½¿ç”¨å‡½æ•°å¼æ›´æ–°ç¡®ä¿è·å–æœ€æ–°çš„playerHpå€¼
      setPlayerHp(currentHp => {
        const newPlayerHp = Math.max(0, currentHp - actualDamage);
        
        // æ£€æŸ¥ç©å®¶æ˜¯å¦è¢«å‡»è´¥
        if (newPlayerHp <= 0) {
          setTimeout(() => setPhase('player-lost'), 800);
        } else {
          setTimeout(() => setPhase('player-turn'), 1000);
        }
        
        return newPlayerHp;
      });
    }
  };
